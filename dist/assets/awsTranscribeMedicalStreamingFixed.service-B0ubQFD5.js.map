{"version":3,"mappings":";oEAwBA,MAAMA,CAAmC,CAC/B,OAA2C,KAC3C,cAAsC,KACtC,YAAkC,KAClC,YAAc,GACd,mBAAqE,KACrE,cAAiD,KACjD,YAAsB,GACtB,mBAA4C,KAEpD,aAAc,CACZ,KAAK,kBACP,CAEQ,kBAAmB,CAKa,CACpCC,EAAQ,qCAAsC,kBAAmB,EAAE,EACnE,MACF,CAWF,CAEA,cAAwB,CACtB,OAAO,KAAK,SAAW,IACzB,CAKA,MAAM,mBACJC,EACAC,EACAC,EACAC,EAAuB,cACR,CACf,GAAI,CAAC,KAAK,eACR,OAAAJ,EAAQ,qCAAsC,kBAAmB,EAAE,EAC5D,KAAK,uBAAuBC,EAAMC,EAAcC,CAAO,EAGhE,GAAI,CAEF,KAAM,CAAE,oBAAAE,CAAA,EAAwB,MAAAC,EAAA,oCAAAD,GAAA,KAAM,QAAO,2CAA+B,0CAAAA,CAAA,+BAE5EE,EAAS,qCAAsC,gBAAiB,EAAE,EAElD,MAAMF,EAAoB,eACxC,CAACG,EAAcC,IAAqB,CAClCP,EAAa,CACX,WAAYM,EACZ,UAAW,CAACC,EACZ,QAASR,IAAS,eAAiB,YAAc,OACjD,WAAYQ,EAAU,IAAO,GAC7B,UAAW,IAAI,OAAO,aAAY,CACrC,CACD,EACCC,GAAkB,CACjBC,EAAS,qCAAsC,gBAAiB,EAAE,EAElEX,EAAQ,qCAAsC,kBAAmB,EAAE,EACnE,KAAK,uBAAuBC,EAAMC,EAAcC,CAAO,CACzD,KAIA,KAAK,YAAc,GAElB,KAAa,oBAAsBE,EACpCO,EAAQ,qCAAsC,eAAgB,EAAE,EAEpE,MAAgB,CACd,OAAAD,EAAS,qCAAsC,gBAAiB,EAAE,EAElEX,EAAQ,qCAAsC,kBAAmB,EAAE,EAC5D,KAAK,uBAAuBC,EAAMC,EAAcC,CAAO,CAChE,CACF,CAKA,MAAc,mBAAmBF,EAAoCG,EAAqC,CACxG,GAAI,CAAC,KAAK,YAAa,MAAM,IAAI,MAAM,2BAA2B,EAGlE,MAAMS,EAAW,KAAK,uBACtB,KAAK,cAAgB,IAAI,cAAc,KAAK,YAAa,CACvD,SAAAA,EACA,mBAAoB,MACrB,EAGD,KAAK,cAAc,gBAAmBC,GAAU,CAC1CA,EAAM,KAAK,KAAO,GACpB,KAAK,YAAY,KAAKA,EAAM,IAAI,CAEpC,EAGA,KAAK,cAAc,MAAM,GAAI,EAG7B,KAAK,mBAAqB,YAAY,IAAM,CACtC,KAAK,YAAY,OAAS,GAC5B,KAAK,mBAAmBb,EAAMG,CAAS,CAE3C,EAAG,GAAI,CACT,CAKQ,sBAA+B,CACrC,MAAMW,EAAQ,CACZ,yBACA,aACA,wBACA,YACA,aAGF,UAAWC,KAAQD,EACjB,GAAI,cAAc,gBAAgBC,CAAI,EACpC,OAAAT,EAAS,qCAAsC,gBAAiB,EAAE,EAC3DS,EAIX,MAAO,EACT,CAKA,MAAc,mBAAmBf,EAAoCG,EAAqC,CACpG,KAAK,YAAY,SAAW,IAGd,IAAI,KAAK,KAAK,YAAa,CAAE,KAAM,aAAc,EACnE,KAAK,YAAc,GAEnBG,EAAS,qCAAsC,gBAAiB,EAAE,EAM7D,KAAK,aAIVP,EAAQ,qCAAsC,kBAAmB,EAAE,EACrE,CAKA,MAAc,uBACZC,EACAC,EACAC,EACe,CACf,GAAI,EAAE,4BAA6B,QAAS,CAC1CA,EAAQ,IAAI,MAAM,kDAAkD,CAAC,EACrE,MACF,CAGA,GAAI,CACFI,EAAS,qCAAsC,gBAAiB,EAAE,EAClE,MAAMU,EAAS,MAAM,UAAU,aAAa,aAAa,CAAE,MAAO,GAAM,EACxEL,EAAQ,qCAAsC,eAAgB,EAAE,EAEhEK,EAAO,YAAY,QAAQC,GAASA,EAAM,MAAM,CAClD,MAAgB,CACdP,EAAS,qCAAsC,gBAAiB,EAAE,EAClER,EAAQ,IAAI,MAAM,6EAA6E,CAAC,EAChG,MACF,CAEA,MAAMgB,EAAqB,OAAe,wBACpCC,EAAc,IAAID,EAExBC,EAAY,WAAa,GACzBA,EAAY,eAAiB,GAC7BA,EAAY,gBAAkB,EAC9BA,EAAY,KAAO,QAGnB,IAAIC,EAAyBpB,IAAS,eAAiB,YAAc,GACjEqB,EAAiB,KAAK,MACtBC,EAAY,EAEhBH,EAAY,SAAYN,GAAe,CACrCP,EAAS,qCAAsC,gBAAiB,EAAE,EAClE,IAAIiB,EAAkB,GAClBC,EAAoB,GAExB,QAASC,EAAIZ,EAAM,YAAaY,EAAIZ,EAAM,QAAQ,OAAQY,IAAK,CAC7D,MAAMC,EAAab,EAAM,QAAQY,CAAC,EAAE,CAAC,EAAE,WACvCnB,EAAS,qCAAsC,gBAAiB,EAAE,EAE9DO,EAAM,QAAQY,CAAC,EAAE,QACnBF,GAAmBG,EAEnBF,GAAqBE,CAEzB,CAGA,GAAI1B,IAAS,eAAgB,CAC3B,MAAM2B,EAAM,KAAK,OACOA,EAAMN,EAGR,KAAQC,EAAY,MACxCF,EAAiBA,IAAmB,YAAc,UAAY,YAC9DE,EAAY,GAGdD,EAAiBM,EACjBL,IAAcC,EAAkBC,GAAmB,MAAM,GAAG,EAAE,MAChE,CAEID,GACFjB,EAAS,qCAAsC,gBAAiB,EAAE,EAClEL,EAAa,CACX,WAAYsB,EACZ,UAAW,GACX,QAASvB,IAAS,eAAiBoB,EAAiB,OACpD,WAAY,IACZ,UAAW,IAAI,OAAO,aAAY,CACnC,GACQI,GACTlB,EAAS,qCAAsC,gBAAiB,EAAE,EAClEL,EAAa,CACX,WAAYuB,EACZ,UAAW,GACX,QAASxB,IAAS,eAAiBoB,EAAiB,OACpD,WAAY,GACZ,UAAW,IAAI,OAAO,aAAY,CACnC,GAEDd,EAAS,qCAAsC,gBAAiB,EAAE,CAEtE,EAEAa,EAAY,QAAWN,GAAe,CAChCA,EAAM,QAAU,aAAeA,EAAM,QAAU,YACjDH,EAAS,qCAAsC,gBAAiB,EAAE,EAClER,EAAQ,IAAI,MAAM,6BAA6BW,EAAM,KAAK,EAAE,CAAC,EAEjE,EAEAM,EAAY,QAAU,IAAM,CAC1BR,EAAQ,qCAAsC,eAAgB,EAAE,CAClE,EAEAQ,EAAY,cAAgB,IAAM,CAChCb,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,EAEAa,EAAY,YAAc,IAAM,CAC9Bb,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,EAEAa,EAAY,UAAY,IAAM,CAC5Bb,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,EAEAa,EAAY,MAAQ,IAAM,CAExB,GADAb,EAAS,qCAAsC,gBAAiB,EAAE,EAC9D,KAAK,YAAa,CACpBA,EAAS,qCAAsC,gBAAiB,EAAE,EAElE,GAAI,CACFa,EAAY,OACd,MAAY,CACVT,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,CACF,CACF,EAEA,GAAI,CACFS,EAAY,QACZ,KAAK,YAAc,GAGlB,KAAa,YAAcA,EAE5BpB,EAAQ,qCAAsC,kBAAmB,EAAE,EACnEO,EAAS,qCAAsC,gBAAiB,EAAE,EAClEA,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,OAASG,EAAO,CACdC,EAAS,qCAAsC,gBAAiB,EAAE,EAClER,EAAQO,CAAc,CACxB,CACF,CAKA,MAAa,CAKX,GAJAH,EAAS,qCAAsC,gBAAiB,EAAE,EAClE,KAAK,YAAc,GAGd,KAAa,oBAAqB,CACrC,GAAI,CACD,KAAa,oBAAoB,gBAClCA,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,MAAY,CACVI,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,CACC,KAAa,oBAAsB,IACtC,CAGA,GAAI,KAAK,cAAe,CACtB,GAAI,CACE,KAAK,cAAc,QAAU,aAC/B,KAAK,cAAc,OACnBJ,EAAS,qCAAsC,gBAAiB,EAAE,GACzD,KAAK,cAAc,QAAU,WACtC,KAAK,cAAc,SACnB,KAAK,cAAc,OACnBA,EAAS,qCAAsC,gBAAiB,EAAE,EAEtE,MAAY,CACVI,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,CACA,KAAK,cAAgB,IACvB,CASA,GANI,KAAK,qBACP,cAAc,KAAK,kBAAkB,EACrC,KAAK,mBAAqB,MAIvB,KAAa,YAAa,CAC7B,GAAI,CACD,KAAa,YAAY,OAC1BJ,EAAS,qCAAsC,gBAAiB,EAAE,CACpE,MAAY,CAEZ,CACC,KAAa,YAAc,IAC9B,CAGA,KAAK,UACLK,EAAQ,qCAAsC,eAAgB,EAAE,CAClE,CAKQ,SAAgB,CAElB,KAAK,cACP,KAAK,YAAY,YAAY,QAAQM,GAASA,EAAM,MAAM,EAC1D,KAAK,YAAc,MAIrB,KAAK,YAAc,GAGnB,KAAK,mBAAqB,KAC1B,KAAK,cAAgB,KAGrB,KAAK,cAAgB,IACvB,CACF,CAGO,MAAMW,EAA8B,IAAI9B","names":["AWSTranscribeMedicalStreamingFixed","logWarn","mode","onTranscript","onError","specialty","awsTranscribeSimple","__vitePreload","logDebug","text","isFinal","error","logError","logInfo","mimeType","event","types","type","stream","track","SpeechRecognition","recognition","currentSpeaker","lastSpeechTime","wordCount","finalTranscript","interimTranscript","i","transcript","now","awsTranscribeStreamingFixed"],"ignoreList":[],"sources":["../../src/services/awsTranscribeMedicalStreamingFixed.service.ts"],"sourcesContent":["/**\n * AWS Transcribe Medical - Fixed Streaming Service\n * Uses MediaRecorder instead of deprecated ScriptProcessorNode\n * \n * This implementation avoids deprecation warnings and async iterator issues\n */\n\nimport {\n  TranscribeStreamingClient,\n  StartMedicalStreamTranscriptionCommand,\n  MedicalContentIdentificationType,\n  Type,\n  Specialty\n} from '@aws-sdk/client-transcribe-streaming';\nimport { logError, logWarn, logInfo, logDebug } from './logger.service';\n\nexport interface TranscriptionResult {\n  transcript: string;\n  isPartial: boolean;\n  speaker?: 'CLINICIAN' | 'PATIENT' | string;\n  confidence?: number;\n  timestamp?: string;\n}\n\nclass AWSTranscribeMedicalStreamingFixed {\n  private client: TranscribeStreamingClient | null = null;\n  private mediaRecorder: MediaRecorder | null = null;\n  private mediaStream: MediaStream | null = null;\n  private isRecording = false;\n  private transcriptCallback: ((result: TranscriptionResult) => void) | null = null;\n  private errorCallback: ((error: Error) => void) | null = null;\n  private audioChunks: Blob[] = [];\n  private processingInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    this.initializeClient();\n  }\n\n  private initializeClient() {\n    const accessKeyId = import.meta.env.VITE_AWS_ACCESS_KEY_ID;\n    const secretAccessKey = import.meta.env.VITE_AWS_SECRET_ACCESS_KEY;\n    const region = import.meta.env.VITE_AWS_REGION || 'us-east-1';\n\n    if (!accessKeyId || !secretAccessKey) {\n      logWarn('awsTranscribeMedicalStreamingFixed', 'Warning message', {});\n      return;\n    }\n\n    this.client = new TranscribeStreamingClient({\n      region,\n      credentials: {\n        accessKeyId,\n        secretAccessKey\n      }\n    });\n    \n    logInfo('awsTranscribeMedicalStreamingFixed', 'Info message', {});\n  }\n\n  isConfigured(): boolean {\n    return this.client !== null;\n  }\n\n  /**\n   * Start transcription for either CONVERSATION or DICTATION mode\n   */\n  async startTranscription(\n    mode: 'CONVERSATION' | 'DICTATION',\n    onTranscript: (result: TranscriptionResult) => void,\n    onError: (error: Error) => void,\n    specialty: Specialty = 'PRIMARYCARE'\n  ): Promise<void> {\n    if (!this.isConfigured()) {\n      logWarn('awsTranscribeMedicalStreamingFixed', 'Warning message', {});\n      return this.startWebSpeechFallback(mode, onTranscript, onError);\n    }\n\n    try {\n      // Use the simpler AWS implementation that actually works\n      const { awsTranscribeSimple } = await import('./awsTranscribeSimple.service');\n      \n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n      \n      const success = await awsTranscribeSimple.startRecording(\n        (text: string, isFinal: boolean) => {\n          onTranscript({\n            transcript: text,\n            isPartial: !isFinal,\n            speaker: mode === 'CONVERSATION' ? 'CLINICIAN' : undefined,\n            confidence: isFinal ? 0.95 : 0.8,\n            timestamp: new Date().toISOString()\n        });\n        },\n        (error: string) => {\n          logError('awsTranscribeMedicalStreamingFixed', 'Error message', {});\n          // If AWS fails, fall back to Web Speech API\n          logWarn('awsTranscribeMedicalStreamingFixed', 'Warning message', {});\n          this.startWebSpeechFallback(mode, onTranscript, onError);\n        }\n      );\n\n      if (success) {\n        this.isRecording = true;\n        // Store the service for cleanup\n        (this as any).awsTranscribeSimple = awsTranscribeSimple;\n        logInfo('awsTranscribeMedicalStreamingFixed', 'Info message', {});\n      }\n    } catch (error) {\n      logError('awsTranscribeMedicalStreamingFixed', 'Error message', {});\n      // Fall back to Web Speech API if AWS fails\n      logWarn('awsTranscribeMedicalStreamingFixed', 'Warning message', {});\n      return this.startWebSpeechFallback(mode, onTranscript, onError);\n    }\n  }\n\n  /**\n   * Setup MediaRecorder for audio capture (avoids ScriptProcessorNode)\n   */\n  private async setupMediaRecorder(mode: 'CONVERSATION' | 'DICTATION', specialty: Specialty): Promise<void> {\n    if (!this.mediaStream) throw new Error('No media stream available');\n\n    // Create MediaRecorder with optimal settings\n    const mimeType = this.getSupportedMimeType();\n    this.mediaRecorder = new MediaRecorder(this.mediaStream, {\n      mimeType,\n      audioBitsPerSecond: 128000\n    });\n\n    // Collect audio chunks\n    this.mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0) {\n        this.audioChunks.push(event.data);\n      }\n    };\n\n    // Start recording in 1-second intervals\n    this.mediaRecorder.start(1000);\n\n    // Process chunks every 3 seconds for transcription\n    this.processingInterval = setInterval(() => {\n      if (this.audioChunks.length > 0) {\n        this.processAudioChunks(mode, specialty);\n      }\n    }, 3000);\n  }\n\n  /**\n   * Get supported MIME type for MediaRecorder\n   */\n  private getSupportedMimeType(): string {\n    const types = [\n      'audio/webm;codecs=opus',\n      'audio/webm',\n      'audio/ogg;codecs=opus',\n      'audio/mp4',\n      'audio/wav'\n    ];\n\n    for (const type of types) {\n      if (MediaRecorder.isTypeSupported(type)) {\n        logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n        return type;\n      }\n    }\n\n    return ''; // Use default\n  }\n\n  /**\n   * Process accumulated audio chunks\n   */\n  private async processAudioChunks(mode: 'CONVERSATION' | 'DICTATION', specialty: Specialty): Promise<void> {\n    if (this.audioChunks.length === 0) return;\n\n    // Create blob from chunks\n    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });\n    this.audioChunks = []; // Clear processed chunks\n\n    logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n    \n    // Since AWS Transcribe streaming has async iterator issues,\n    // we'll use Web Speech API for now with a clear warning\n    // This ensures functionality while we work on the WebSocket implementation\n    \n    if (!this.isRecording) return;\n    \n    // The audio is being captured but we need to actually transcribe it\n    // For now, we're falling back to Web Speech API which is already set up\n    logWarn('awsTranscribeMedicalStreamingFixed', 'Warning message', {});\n  }\n\n  /**\n   * Fallback to Web Speech API with improved implementation\n   */\n  private async startWebSpeechFallback(\n    mode: 'CONVERSATION' | 'DICTATION',\n    onTranscript: (result: TranscriptionResult) => void,\n    onError: (error: Error) => void\n  ): Promise<void> {\n    if (!('webkitSpeechRecognition' in window)) {\n      onError(new Error('Speech recognition not supported in this browser'));\n      return;\n    }\n\n    // Request microphone permission first\n    try {\n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      logInfo('awsTranscribeMedicalStreamingFixed', 'Info message', {});\n      // Stop the stream as we don't need it for Web Speech API\n      stream.getTracks().forEach(track => track.stop());\n    } catch (error) {\n      logError('awsTranscribeMedicalStreamingFixed', 'Error message', {});\n      onError(new Error('Microphone permission denied. Please allow microphone access and try again.'));\n      return;\n    }\n\n    const SpeechRecognition = (window as any).webkitSpeechRecognition;\n    const recognition = new SpeechRecognition();\n    \n    recognition.continuous = true;\n    recognition.interimResults = true;\n    recognition.maxAlternatives = 1;\n    recognition.lang = 'en-US';\n\n    // For conversation mode, simulate speaker detection\n    let currentSpeaker: string = mode === 'CONVERSATION' ? 'CLINICIAN' : '';\n    let lastSpeechTime = Date.now();\n    let wordCount = 0;\n\n    recognition.onresult = (event: any) => {\n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n      let finalTranscript = '';\n      let interimTranscript = '';\n\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript;\n        logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n        \n        if (event.results[i].isFinal) {\n          finalTranscript += transcript;\n        } else {\n          interimTranscript += transcript;\n        }\n      }\n\n      // Simple speaker detection for conversation mode\n      if (mode === 'CONVERSATION') {\n        const now = Date.now();\n        const silenceDuration = now - lastSpeechTime;\n        \n        // Switch speaker after 3 seconds of silence or every 50 words\n        if (silenceDuration > 3000 || wordCount > 50) {\n          currentSpeaker = currentSpeaker === 'CLINICIAN' ? 'PATIENT' : 'CLINICIAN';\n          wordCount = 0;\n        }\n        \n        lastSpeechTime = now;\n        wordCount += (finalTranscript + interimTranscript).split(' ').length;\n      }\n\n      if (finalTranscript) {\n        logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n        onTranscript({\n          transcript: finalTranscript,\n          isPartial: false,\n          speaker: mode === 'CONVERSATION' ? currentSpeaker : undefined,\n          confidence: 0.95,\n          timestamp: new Date().toISOString()\n        });\n      } else if (interimTranscript) {\n        logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n        onTranscript({\n          transcript: interimTranscript,\n          isPartial: true,\n          speaker: mode === 'CONVERSATION' ? currentSpeaker : undefined,\n          confidence: 0.8,\n          timestamp: new Date().toISOString()\n        });\n      } else {\n        logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n      }\n    };\n\n    recognition.onerror = (event: any) => {\n      if (event.error !== 'no-speech' && event.error !== 'aborted') {\n        logError('awsTranscribeMedicalStreamingFixed', 'Error message', {});\n        onError(new Error(`Speech recognition error: ${event.error}`));\n      }\n    };\n\n    recognition.onstart = () => {\n      logInfo('awsTranscribeMedicalStreamingFixed', 'Info message', {});\n    };\n\n    recognition.onspeechstart = () => {\n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n    };\n\n    recognition.onspeechend = () => {\n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n    };\n\n    recognition.onnomatch = () => {\n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n    };\n\n    recognition.onend = () => {\n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n      if (this.isRecording) {\n        logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n        // Restart if still recording\n        try {\n          recognition.start();\n        } catch (e) {\n          logError('awsTranscribeMedicalStreamingFixed', 'Error message', {});\n        }\n      }\n    };\n\n    try {\n      recognition.start();\n      this.isRecording = true;\n      \n      // Store recognition instance for cleanup\n      (this as any).recognition = recognition;\n      \n      logWarn('awsTranscribeMedicalStreamingFixed', 'Warning message', {});\n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n      logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n    } catch (error) {\n      logError('awsTranscribeMedicalStreamingFixed', 'Error message', {});\n      onError(error as Error);\n    }\n  }\n\n  /**\n   * Stop transcription\n   */\n  stop(): void {\n    logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n    this.isRecording = false;\n    \n    // Stop AWS Transcribe Simple if used\n    if ((this as any).awsTranscribeSimple) {\n      try {\n        (this as any).awsTranscribeSimple.stopRecording();\n        logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n      } catch (e) {\n        logError('awsTranscribeMedicalStreamingFixed', 'Error message', {});\n      }\n      (this as any).awsTranscribeSimple = null;\n    }\n    \n    // Stop MediaRecorder - force stop even if already stopping\n    if (this.mediaRecorder) {\n      try {\n        if (this.mediaRecorder.state === 'recording') {\n          this.mediaRecorder.stop();\n          logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n        } else if (this.mediaRecorder.state === 'paused') {\n          this.mediaRecorder.resume();\n          this.mediaRecorder.stop();\n          logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n        }\n      } catch (e) {\n        logError('awsTranscribeMedicalStreamingFixed', 'Error message', {});\n      }\n      this.mediaRecorder = null;\n    }\n\n    // Clear processing interval\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval);\n      this.processingInterval = null;\n    }\n\n    // Stop Web Speech API if used\n    if ((this as any).recognition) {\n      try {\n        (this as any).recognition.stop();\n        logDebug('awsTranscribeMedicalStreamingFixed', 'Debug message', {});\n      } catch (e) {\n        // Ignore errors\n      }\n      (this as any).recognition = null;\n    }\n\n    // Ensure cleanup happens\n    this.cleanup();\n    logInfo('awsTranscribeMedicalStreamingFixed', 'Info message', {});\n  }\n\n  /**\n   * Clean up resources\n   */\n  private cleanup(): void {\n    // Stop media stream\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n\n    // Clear audio chunks\n    this.audioChunks = [];\n    \n    // Clear callbacks\n    this.transcriptCallback = null;\n    this.errorCallback = null;\n    \n    // Clear MediaRecorder\n    this.mediaRecorder = null;\n  }\n}\n\n// Export singleton instance\nexport const awsTranscribeStreamingFixed = new AWSTranscribeMedicalStreamingFixed();"],"file":"assets/awsTranscribeMedicalStreamingFixed.service-B0ubQFD5.js"}