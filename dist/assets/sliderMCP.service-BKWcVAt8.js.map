{"version":3,"file":"sliderMCP.service-BKWcVAt8.js","sources":["../../src/services/sliderMCP.service.ts"],"sourcesContent":["// Enhanced with comprehensive pump database\nimport {\n  COMPREHENSIVE_PUMP_DATABASE,\n  findPumpByName,\n  type ComprehensivePumpData,\n} from '../data/pumpDataComprehensive';\nimport { logError, logWarn, logInfo, logDebug } from './logger.service';\n\n// Local interface definitions to avoid import issues\ninterface SliderResponse {\n  sliderId: string;\n  value: number;\n  timestamp: number;\n  category: string;\n}\n\ninterface SliderProfile {\n  userId?: string;\n  sessionId: string;\n  responses: SliderResponse[];\n  profileHash: string;\n  createdAt: number;\n  completedAt?: number;\n}\n\ninterface SliderRecommendation {\n  profileId: string;\n  topPumps: Array<{\n    pumpId: string;\n    pumpName: string;\n    score: number;\n    matchFactors: string[];\n    sliderInfluence: Record<string, number>;\n    pumpSpecs?: ComprehensivePumpData;\n  }>;\n  personalizedInsights: string[];\n  nextSteps: string[];\n  confidence: number;\n}\n\n// Local interface definition to avoid export issues\ninterface SliderAnalysis {\n  profile: SliderProfile;\n  recommendation: SliderRecommendation;\n  cacheKey: string;\n  processingTime: number;\n  source: 'cache' | 'ai';\n}\nimport { openAIService } from './openai.service';\n\ninterface MCPResponse {\n  found: boolean;\n  recommendation?: string;\n  profileId?: string;\n  profileHash?: string;\n  age_ms?: number;\n  hits?: number;\n  success?: boolean;\n  cached?: boolean;\n  error?: string;\n}\n\nclass SliderMCPService {\n  private sessionId: string = '';\n\n  constructor() {\n    this.sessionId = this.generateSessionId();\n  }\n\n  private generateSessionId(): string {\n    return `slider_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateProfileHash(\n    sliderData: Record<string, number>,\n    selectedFeatures?: any[],\n    freeText?: string\n  ): string {\n    // Create consistent hash from ALL assessment data\n    const sliderString = Object.keys(sliderData)\n      .sort()\n      .map(key => `${key}:${sliderData[key]}`)\n      .join(',');\n    const featuresString = (selectedFeatures || [])\n      .map(f => f.title || f.id || '')\n      .sort()\n      .join(',');\n    const storyString = (freeText || '').toLowerCase().replace(/[^a-z0-9]/g, '');\n\n    const combinedData = `sliders:${sliderString}|features:${featuresString}|story:${storyString}`;\n    return btoa(combinedData)\n      .replace(/[^a-zA-Z0-9]/g, '')\n      .substring(0, 32);\n  }\n\n  async saveSliderProfile(\n    sliderData: Record<string, number>\n  ): Promise<{ profileId: string; profileHash: string }> {\n    logDebug('sliderMCP', 'Debug message', {});\n\n    const profile: SliderProfile = {\n      sessionId: this.sessionId,\n      responses: Object.entries(sliderData).map(([key, value]) => ({\n        sliderId: key,\n        value,\n        timestamp: Date.now(),\n        category: key,\n      })),\n      profileHash: this.generateProfileHash(sliderData, [], ''),\n      createdAt: Date.now(),\n    };\n\n    try {\n      // In a real MCP implementation, this would call the MCP server\n      // For now, we'll simulate the MCP call and store locally\n      const profileData = JSON.stringify(profile);\n\n      // Simulate MCP server call\n      const response: MCPResponse = {\n        success: true,\n        profileId: `profile_${Date.now()}`,\n        profileHash: profile.profileHash,\n      };\n\n      logInfo('sliderMCP', 'Info message', {});\n\n      // Also save to localStorage as backup\n      localStorage.setItem(`slider_profile_${response.profileId}`, profileData);\n\n      return {\n        profileId: response.profileId!,\n        profileHash: response.profileHash!,\n      };\n    } catch (error) {\n      logError('sliderMCP', 'Error message', {});\n      throw new Error('Failed to save slider profile');\n    }\n  }\n\n  async getSliderRecommendation(profileHash: string): Promise<SliderRecommendation | null> {\n    logDebug('sliderMCP', 'Debug message', {});\n\n    try {\n      // In a real MCP implementation, this would call the MCP server\n      // For now, we'll check localStorage cache\n      const cachedData = this.checkLocalCache(profileHash);\n\n      if (cachedData) {\n        logDebug('sliderMCP', 'Debug message', {});\n        return cachedData;\n      }\n\n      logDebug('sliderMCP', 'Debug message', {});\n      return null;\n    } catch (error) {\n      logError('sliderMCP', 'Error message', {});\n      return null;\n    }\n  }\n\n  private checkLocalCache(profileHash: string): SliderRecommendation | null {\n    try {\n      const cacheKey = `slider_rec_${profileHash}`;\n      const cached = localStorage.getItem(cacheKey);\n\n      if (cached) {\n        const data = JSON.parse(cached);\n        const hourAgo = Date.now() - 3600000; // 1 hour TTL\n\n        if (data.createdAt > hourAgo) {\n          return data.recommendation;\n        }\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n\n  async generateRecommendation(\n    sliderData: Record<string, number>,\n    selectedFeatures: any[] = []\n  ): Promise<SliderAnalysis> {\n    logDebug('sliderMCP', 'Debug message', {});\n\n    const startTime = Date.now();\n    const freeTextForHash = this.getFreeTextResponse();\n    const profileHash = this.generateProfileHash(sliderData, selectedFeatures, freeTextForHash);\n\n    // Check cache first\n    let cachedRecommendation = await this.getSliderRecommendation(profileHash);\n\n    if (cachedRecommendation) {\n      return {\n        profile: {\n          sessionId: this.sessionId,\n          responses: Object.entries(sliderData).map(([key, value]) => ({\n            sliderId: key,\n            value,\n            timestamp: Date.now(),\n            category: key,\n          })),\n          profileHash,\n          createdAt: Date.now(),\n        },\n        recommendation: cachedRecommendation,\n        cacheKey: profileHash,\n        processingTime: Date.now() - startTime,\n        source: 'cache',\n      };\n    }\n\n    // Use passed selectedFeatures or fallback to session storage\n    const featuresData =\n      selectedFeatures.length > 0 ? selectedFeatures : this.getSelectedFeatures();\n    // Get free text response from session storage\n    const freeTextData = sessionStorage.getItem('pumpDriveFreeText');\n    const freeTextResponse = freeTextData ? JSON.parse(freeTextData)?.currentSituation : '';\n\n    const enhancedPrompt = this.buildEnhancedAIPrompt(sliderData, featuresData, freeTextResponse);\n\n    try {\n      const aiResponse = await openAIService.processText(enhancedPrompt, { model: 'gpt-4', temperature: 0.7, maxTokens: 2000 });\n      const recommendation = this.parseAIResponse(aiResponse, sliderData);\n\n      // Feature boosting removed - AI handles feature preferences objectively in the prompt\n\n      // Cache the recommendation\n      await this.cacheRecommendation(profileHash, recommendation);\n\n      return {\n        profile: {\n          sessionId: this.sessionId,\n          responses: Object.entries(sliderData).map(([key, value]) => ({\n            sliderId: key,\n            value,\n            timestamp: Date.now(),\n            category: key,\n          })),\n          profileHash,\n          createdAt: Date.now(),\n        },\n        recommendation,\n        cacheKey: profileHash,\n        processingTime: Date.now() - startTime,\n        source: 'ai',\n      };\n    } catch (error) {\n      logError('sliderMCP', 'Error message', {});\n      throw new Error('Failed to generate pump recommendation');\n    }\n  }\n\n  private getSelectedFeatures(): any[] {\n    try {\n      const featuresData = sessionStorage.getItem('selectedPumpFeatures');\n      return featuresData ? JSON.parse(featuresData) : [];\n    } catch {\n      return [];\n    }\n  }\n\n  private getFreeTextResponse(): string {\n    try {\n      const freeTextData = sessionStorage.getItem('pumpDriveFreeText');\n      if (freeTextData) {\n        const data = JSON.parse(freeTextData);\n        return data.currentSituation || '';\n      }\n      return '';\n    } catch {\n      return '';\n    }\n  }\n\n  private buildEnhancedAIPrompt(\n    sliderData: Record<string, number>,\n    selectedFeatures: any[],\n    freeTextResponse?: string\n  ): string {\n    // Build comprehensive assessment summary\n    let enhancedPrompt = `üéØ COMPLETE USER ASSESSMENT - INSULIN PUMP RECOMMENDATION\n\nYou are helping a person with diabetes choose the perfect insulin pump based on their complete assessment. Please provide a highly personalized recommendation based on ALL the information below.\n\nCRITICAL ANALYSIS INSTRUCTIONS:\n- DO NOT use any pre-calculated scores or ranking biases\n- Analyze the patient's responses objectively without any pre-programmed scoring systems\n- Base recommendations purely on objective analysis of patient needs against pump specifications\n\nANALYSIS PRIORITY HIERARCHY:\n1. **EXPLICIT FEATURE SELECTIONS**: Features the patient specifically selected carry the highest weight\n   - If patient selected \"Apple Watch bolusing\" ‚Üí ONLY Twiist supports this (major factor)\n   - If patient selected \"2 ounces weight\" ‚Üí ONLY Twiist offers this (major factor)\n   - If patient selected \"swap batteries\" ‚Üí Favor pumps with replaceable batteries\n2. **PERSONAL STORY KEYWORDS**: Specific medical/lifestyle needs mentioned in free text\n3. **SLIDER PREFERENCES**: General lifestyle ratings are lower priority than explicit selections\n\nCRITICAL PUMP FACTS:\n- Apple Watch bolusing: ONLY Twiist supports this feature\n- Lightest weight (2 oz): ONLY Twiist offers this\n- Tandem Mobi: iPhone-only, no Apple Watch control, not 2 oz\n- If patient selected both \"Apple Watch\" AND \"2 oz\" features ‚Üí Twiist should be heavily favored unless major contraindications exist\n\n`;\n\n    // Section 1: Slider Preferences\n    const { activity, techComfort, simplicity, discreteness, timeDedication } = sliderData;\n\n    enhancedPrompt += `üìä USER'S LIFESTYLE PREFERENCES (1-10 scale):\n\nüèÉ Activity Level: ${activity}/10\n`;\n    if (activity <= 3) enhancedPrompt += `   ‚Üí Mostly sedentary, prefers comfort and stability`;\n    else if (activity >= 7)\n      enhancedPrompt += `   ‚Üí Very active lifestyle, needs durable and flexible solutions`;\n    else enhancedPrompt += `   ‚Üí Moderately active, balanced lifestyle needs`;\n\n    enhancedPrompt += `\nüì± Technology Love: ${techComfort}/10\n`;\n    if (techComfort <= 3)\n      enhancedPrompt += `   ‚Üí Prefers simple, basic technology with minimal complexity`;\n    else if (techComfort >= 7)\n      enhancedPrompt += `   ‚Üí Loves technology, early adopter, wants advanced features`;\n    else enhancedPrompt += `   ‚Üí Comfortable with technology but not obsessed`;\n\n    enhancedPrompt += `\nüéõÔ∏è Complexity Preference: ${simplicity}/10\n`;\n    if (simplicity <= 3)\n      enhancedPrompt += `   ‚Üí Wants simple, straightforward devices with minimal options`;\n    else if (simplicity >= 7)\n      enhancedPrompt += `   ‚Üí Enjoys advanced features, data, and control options`;\n    else enhancedPrompt += `   ‚Üí Likes some features but not overwhelming complexity`;\n\n    enhancedPrompt += `\nü§´ Privacy/Discreteness: ${discreteness}/10\n`;\n    if (discreteness <= 3)\n      enhancedPrompt += `   ‚Üí Device must be completely hidden, very concerned about visibility`;\n    else if (discreteness >= 7)\n      enhancedPrompt += `   ‚Üí Doesn't care who sees it, function over appearance`;\n    else enhancedPrompt += `   ‚Üí Prefers discreet but okay if sometimes visible`;\n\n    enhancedPrompt += `\n‚è∞ Time for Device Care: ${timeDedication}/10\n`;\n    if (timeDedication <= 3)\n      enhancedPrompt += `   ‚Üí Wants set-and-forget simplicity with minimal maintenance`;\n    else if (timeDedication >= 7)\n      enhancedPrompt += `   ‚Üí Happy to spend time optimizing and maintaining for best results`;\n    else enhancedPrompt += `   ‚Üí Willing to do basic maintenance but not excessive work`;\n\n    // Section 2: Selected Features\n    if (selectedFeatures.length > 0) {\n      const groupedFeatures = selectedFeatures.reduce(\n        (acc, feature) => {\n          const category = feature.category || 'other';\n          if (!acc[category]) acc[category] = [];\n          acc[category].push(feature);\n          return acc;\n        },\n        {} as Record<string, any[]>\n      );\n\n      enhancedPrompt += `\n\n‚≠ê SPECIFIC FEATURES THE USER SELECTED:\nThe user carefully chose ${selectedFeatures.length} features that appeal to them:\n\n`;\n\n      Object.entries(groupedFeatures).forEach(([category, features]) => {\n        const categoryNames: Record<string, string> = {\n          power: 'üîã Power & Charging',\n          design: 'üé® Design & Size',\n          interface: 'üì± Controls & Interface',\n          convenience: '‚ú® Convenience Features',\n          automation: 'ü§ñ Automation Level',\n        };\n\n        enhancedPrompt += `${categoryNames[category] || category.toUpperCase()}:\n`;\n        features.forEach(feature => {\n          enhancedPrompt += `   ${feature.emoji} ${feature.title} - ${feature.description}\n`;\n        });\n        enhancedPrompt += `\n`;\n      });\n\n      enhancedPrompt += `üéØ FEATURE ANALYSIS INSTRUCTIONS:\nConsider the selected features as important factors in your analysis, but evaluate all pumps objectively. Selected features should influence your recommendation, but not create automatic rankings. Balance feature preferences with other factors like lifestyle, medical needs, and overall suitability.`;\n    } else {\n      enhancedPrompt += `\n\n‚≠ê FEATURE SELECTIONS: User did not select specific features, so base recommendation purely on lifestyle preferences.`;\n    }\n\n    // Section 3: Personal Story\n    if (freeTextResponse?.trim()) {\n      enhancedPrompt += `\n\nüí≠ USER'S PERSONAL STORY & CONTEXT:\n\"${freeTextResponse.trim()}\"\n\nüß† ANALYSIS INSTRUCTIONS:\n1. Identify specific concerns, fears, or challenges mentioned\n2. Note what excites them or what they're looking forward to\n3. Understand their current situation and pain points\n4. Look for hints about their personality and values\n5. Address their emotional needs in addition to technical requirements`;\n\n      // Critical pattern detection for tight control\n      if (\n        freeTextResponse?.toLowerCase().includes('tight') &&\n        freeTextResponse?.toLowerCase().includes('control')\n      ) {\n        enhancedPrompt += `\n\nüö® CRITICAL: User explicitly wants TIGHTEST CONTROL\nThis overrides other preferences. Recommend Control-IQ (Tandem) or SmartGuard (Medtronic) as top choices.`;\n      }\n    } else {\n      enhancedPrompt += `\n\nüí≠ PERSONAL STORY: User chose not to share their personal story.`;\n    }\n\n    // Section 4: AI Instructions\n    enhancedPrompt += `\n\nü§ñ RECOMMENDATION INSTRUCTIONS:\n\nAvailable pumps: Omnipod 5, Tandem t:slim X2, Tandem Mobi, Medtronic 780G, Beta Bionics iLet, Twiist\n\nPUMP SPECIFICATIONS (USE FOR DECISIONS):\nTwiist:\n- Weight: 2 ounces\n- Algorithm: Modern adaptive logic (More aggressive: basal modulations similar to microboluses)\n- Frequency: Adjusts every 5 minutes\n- Battery: Rechargeable (4 replaceable batteries)\n- Tubing: Tubed (compact)\n- Water: Water-resistant (splash proof, not submersible)\n- Unique: Apple Watch bolusing, Only 2 ounces, Emoji-based bolusing\n\nOmnipod 5:\n- Weight: Pod weight (tubeless)\n- Algorithm: On-pod adapting algorithm (Continuously learns, uses CGM data)\n- Frequency: Adjusts basal insulin delivery every 5 minutes\n- Battery: Pod battery (disposable - no charging)\n- Tubing: Tubeless pod\n- Water: IP28 (Submersible up to 8 feet for up to 60 mins)\n- Unique: No tubing, Low pod profile, Activity feature\n\nTandem t:slim X2:\n- Weight: Standard tubed pump\n- Algorithm: Control-IQ (MOST AGGRESSIVE, adjusts every 5 minutes)\n- Frequency: Every 5 minutes with predictive adjustments\n- Battery: Rechargeable\n- Tubing: Traditional tubing\n- Water: Water-resistant\n- Unique: Smartphone integration, Most aggressive control, Advanced data analytics\n\nMedtronic 780G:\n- Weight: Standard tubed pump\n- Algorithm: SmartGuard (Very aggressive, predictive)\n- Frequency: Continuous monitoring with adjustments\n- Battery: Rechargeable\n- Tubing: Traditional tubing\n- Water: Water-resistant\n- Unique: Guardian CGM integration, Predictive low glucose suspend\n\niLet:\n- Weight: Standard tubed pump\n- Algorithm: Bionic Pancreas (Moderate, meal announcements only)\n- Frequency: Adaptive dosing\n- Battery: Rechargeable\n- Tubing: Traditional tubing\n- Water: Standard resistance\n- Unique: Minimal user input, Automated dosing decisions\n\nTandem Mobi:\n- Weight: Compact tubed pump\n- Algorithm: Control-IQ (same as t:slim X2)\n- Frequency: Every 5 minutes\n- Battery: Rechargeable\n- Tubing: Shorter tubing design\n- Water: Water-resistant\n- Unique: Smaller form factor, Same advanced algorithm as t:slim X2\n\nCONTROL ALGORITHM RANKINGS (TIGHTEST TO LOOSEST):\n1. Tandem Control-IQ (t:slim X2 & Mobi) - Most aggressive, adjusts every 5 minutes\n2. Medtronic SmartGuard (780G) - Very aggressive, predictive\n3. Omnipod 5 SmartAdjust - Moderate, adjusts every 5 minutes\n4. Twiist Modern Logic - Moderate, more aggressive basal modulations\n5. iLet Bionic Pancreas - Moderate, meal announcements only\n\nWhen user wants \"tightest control\", prioritize pumps 1-2 above.\n\nPlease provide a comprehensive recommendation that:\n1. üéØ CONSIDER: Evaluate pumps with selected features favorably, but maintain objective analysis across all options\n2. PRIORITIZES all pumps matching their selected features over those that don't\n3. CONSIDERS their lifestyle slider preferences\n4. ADDRESSES their personal story and concerns (if shared) \n5. EXPLAINS the \"why\" behind each recommendation\n6. PROVIDES actionable next steps\n\nCRITICAL SCORING RULE: Unique features = Automatic top ranking for that pump. No exceptions unless severe contradictions exist.\n\nRespond with JSON in this exact format:\n{\n  \"topPumps\": [\n    {\n      \"pumpId\": \"omnipod5\",\n      \"pumpName\": \"Omnipod 5\",\n      \"score\": 95,\n      \"matchFactors\": [\"Perfect for active lifestyle\", \"Selected tubeless design feature\"],\n      \"sliderInfluence\": {\"activity\": 9, \"techComfort\": 8, \"simplicity\": 7, \"discreteness\": 8, \"timeDedication\": 9}\n    }\n  ],\n  \"personalizedInsights\": [\"Your high activity score and tubeless feature selection makes Omnipod ideal...\"],\n  \"nextSteps\": [\"Schedule demo with Omnipod\", \"Check insurance coverage for tubeless pumps\"],\n  \"confidence\": 92\n}`;\n\n    return enhancedPrompt;\n  }\n\n  // boostPumpsWithSelectedFeatures method removed - AI handles feature preferences objectively\n\n  private buildAIPrompt(sliderData: Record<string, number>): string {\n    // This method is now deprecated in favor of buildEnhancedAIPrompt\n    // Keeping for backwards compatibility but not used in main flow\n    return this.buildEnhancedAIPrompt(sliderData, [], '');\n  }\n\n  private parseAIResponse(\n    aiResponse: string,\n    sliderData: Record<string, number>\n  ): SliderRecommendation {\n    try {\n      // Handle Claude's markdown formatting - extract JSON from code blocks\n      let cleanResponse = aiResponse;\n      if (aiResponse.includes('```json')) {\n        const jsonMatch = aiResponse.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n        if (jsonMatch) {\n          cleanResponse = jsonMatch[1];\n        }\n      } else if (aiResponse.includes('```')) {\n        const codeMatch = aiResponse.match(/```\\s*([\\s\\S]*?)\\s*```/);\n        if (codeMatch) {\n          cleanResponse = codeMatch[1];\n        }\n      }\n\n      const parsed = JSON.parse(cleanResponse);\n      return {\n        profileId: this.sessionId,\n        topPumps: parsed.topPumps || [],\n        personalizedInsights: parsed.personalizedInsights || [],\n        nextSteps: parsed.nextSteps || [],\n        confidence: parsed.confidence || 85,\n      };\n    } catch (error) {\n      logError('sliderMCP', 'Error parsing AI response - no fallback available', { error });\n      throw new Error('Failed to parse AI recommendation. Please try again.');\n    }\n  }\n\n  private checkForWeightPreference(): boolean {\n    try {\n      // Check session storage for weight keywords\n      const freeTextData = sessionStorage.getItem('pumpDriveFreeText');\n      if (freeTextData) {\n        const data = JSON.parse(freeTextData);\n        const allText =\n          `${data.currentSituation || ''} ${data.concerns || ''} ${data.priorities || ''}`.toLowerCase();\n\n        const hasWeight =\n          allText.includes('light') ||\n          allText.includes('weight') ||\n          allText.includes('2 oz') ||\n          allText.includes('ounce') ||\n          allText.includes('smallest') ||\n          allText.includes('small') ||\n          allText.includes('compact');\n\n        if (hasWeight) {\n          logDebug('sliderMCP', 'Debug message', {});\n          return true;\n        }\n      }\n\n      // Also check any other pump drive responses\n      const responses =\n        sessionStorage.getItem('pumpdrive_responses') ||\n        sessionStorage.getItem('pumpDriveResponses');\n      if (responses) {\n        const data = JSON.parse(responses);\n        const allResponses = Object.values(data).join(' ').toLowerCase();\n        return (\n          allResponses.includes('light') ||\n          allResponses.includes('smallest') ||\n          allResponses.includes('2 oz')\n        );\n      }\n\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  // calculateMatchScore method removed - using pure AI recommendations only\n\n  private generateFallbackRecommendation(sliderData: Record<string, number>): SliderRecommendation {\n    // Fallback scoring removed - throw error to force AI usage\n    throw new Error('Fallback scoring removed. AI recommendation service must be used.');\n  }\n\n  private async cacheRecommendation(\n    profileHash: string,\n    recommendation: SliderRecommendation\n  ): Promise<void> {\n    try {\n      // Cache in localStorage\n      const cacheKey = `slider_rec_${profileHash}`;\n      const cacheData = {\n        recommendation,\n        createdAt: Date.now(),\n      };\n      localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n\n      // In real MCP implementation, this would call the MCP server\n      logDebug('sliderMCP', 'Debug message', {});\n    } catch (error) {\n      logError('sliderMCP', 'Error message', {});\n      // Non-critical error, continue without caching\n    }\n  }\n\n  getCacheStats() {\n    // In real MCP implementation, this would query the MCP server\n    const cacheKeys = Object.keys(localStorage).filter(key => key.startsWith('slider_rec_'));\n\n    return {\n      totalCached: cacheKeys.length,\n      sessionId: this.sessionId,\n      lastGenerated: Date.now(),\n    };\n  }\n\n  clearAllCache(): void {\n    logDebug('sliderMCP', 'Debug message', {});\n\n    // Clear localStorage caches\n    const cacheKeys = Object.keys(localStorage).filter(\n      key => key.startsWith('slider_rec_') || key.startsWith('slider_profile_')\n    );\n\n    cacheKeys.forEach(key => {\n      localStorage.removeItem(key);\n    });\n\n    // Clear session storage assessment data\n    sessionStorage.removeItem('pumpDriveSliders');\n    sessionStorage.removeItem('pumpDriveSelectedFeatures');\n    sessionStorage.removeItem('pumpDriveFreeText');\n    sessionStorage.removeItem('selectedPumpFeatures');\n\n    logInfo('sliderMCP', 'Info message', {});\n  }\n}\n\nexport const sliderMCPService = new SliderMCPService();\n"],"names":["SliderMCPService","sliderData","selectedFeatures","freeText","sliderString","key","featuresString","f","storyString","combinedData","logDebug","profile","value","profileData","response","logInfo","logError","profileHash","cachedData","cacheKey","cached","data","hourAgo","startTime","freeTextForHash","cachedRecommendation","featuresData","freeTextData","freeTextResponse","enhancedPrompt","aiResponse","openAIService","recommendation","activity","techComfort","simplicity","discreteness","timeDedication","groupedFeatures","acc","feature","category","features","cleanResponse","jsonMatch","codeMatch","parsed","error","allText","responses","allResponses","cacheData","sliderMCPService"],"mappings":"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"}