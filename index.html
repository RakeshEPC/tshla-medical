<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>TSHLA Medical</title>
    <!-- Cache bust: 2025-10-15-template-cleanup -->
    <script>
      // Force cache clear on version mismatch
      const APP_VERSION = '2025-10-15-templates';
      const currentVersion = localStorage.getItem('app-version');
      if (currentVersion !== APP_VERSION) {
        localStorage.setItem('app-version', APP_VERSION);
        if ('caches' in window) {
          caches.keys().then(names => {
            names.forEach(name => caches.delete(name));
          });
        }
      }
    </script>
    <script>
      // Comprehensive polyfill for process required by AWS SDK
      if (typeof global === 'undefined') {
        window.global = window;
      }

      if (typeof process === 'undefined') {
        window.process = {
          env: {},
          version: 'v16.0.0',
          versions: {},
          platform: 'browser',
          browser: true,
          nextTick: function (callback) {
            if (typeof callback !== 'function') {
              throw new TypeError('Callback must be a function');
            }
            const args = Array.prototype.slice.call(arguments, 1);
            Promise.resolve().then(() => callback.apply(null, args));
          },
          cwd: function () {
            return '/';
          },
          chdir: function () {},
          umask: function () {
            return 0;
          },
        };
      }

      // Ensure process.nextTick is always available
      if (window.process && typeof window.process.nextTick !== 'function') {
        window.process.nextTick = function (callback) {
          if (typeof callback !== 'function') {
            throw new TypeError('Callback must be a function');
          }
          const args = Array.prototype.slice.call(arguments, 1);
          Promise.resolve().then(() => callback.apply(null, args));
        };
      }

      // Add Buffer polyfill for browser
      if (typeof Buffer === 'undefined') {
        window.Buffer = {
          from: function (data) {
            if (typeof data === 'string') {
              return new TextEncoder().encode(data);
            }
            return data;
          },
          alloc: function (size) {
            return new Uint8Array(size);
          },
          isBuffer: function (obj) {
            return obj instanceof Uint8Array;
          },
        };
      }
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
